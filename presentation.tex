% titlepage-demo.tex
\documentclass{beamer}

% items enclosed in square brackets are optional; explanation below
\title{Flow-Insensitive Points-To Analysis with Term and Set
  Constraints \cite{Foster97flow-insensitivepoints-to}}
\subtitle{Pointer analysis in type theory's clothing!}
\author{Mihir Mehta}
\institute{
  Department of Computer Science\\
  University of Texas, Austin\\
  \texttt{mihir@cs.utexas.edu}
}
\date{20 October, 2014}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline for section \thesection}
    \tableofcontents[currentsection]
  \end{frame}
}

\usepackage{amsmath}
\usepackage{graphicx}

\begin{document}

%--- the titlepage frame -------------------------%
\begin{frame}[plain]
  \titlepage
\end{frame}

\section{Term and set constraints}

\begin{frame}[allowframebreaks]
  \frametitle{Set constraints 101 \cite{DBLP:journals/scp/Aiken99}}
  %% \item Useful for a whole lot of applications
  %%    ranging from register allocation
  %%   to type inference.
  %% \item First formalised \cite{Heintze91adecision} in 1991, solved for good
  %%   \cite{DBLP:conf/focs/CharatonikP94} in 1994.
    \begin{definition}
      Set constraints describe relationships between sets of
      \emph{terms}. They take the form $X \subseteq Y $, where $X$ and
      $Y$ are set expressions, generated by this grammar.
      $ E ::= \alpha | 
      0 | 
      E_1 \cup E_2 | 
      E_1 \cap E_2 | 
      \neg E_1 |
      c(E_1,\dotsc, E_{a(c)})|
      c^{-i}(E_1)$
    \end{definition}
    \begin{definition}
      A system of set constraints is a finite conjunction of
      constraints $ \bigwedge_{i} X_i \subseteq Y_i $.
    \end{definition}
    \begin{definition}
      A solution to a system of set constraints is an assignment
      $ \sigma $ of sets to variables in the system such that all the
      constraints in the system are satisfied when $ \sigma $ is
      extended to set expressions under these rules.
    \end{definition}

    \begin{align*}
      \sigma(0) &= \phi \\
      \sigma(E_1 \cup E_2) &= \sigma (E_1) \cup \sigma (E_2) \\
      \sigma(E_1 \cap E_2) &= \sigma (E_1) \cap \sigma (E_2) \\
      \sigma(\neg E_1) &= H - \sigma (E_1) \\
      \sigma(c(E_1,\dotsc, E_n)) &= \{c(t_1,\dotsc,t_n) | t_i \in \sigma(E_i)\} \\
      \sigma(c^{-i}(E)) &= \{t_i | \exists c(t_1,\dotsc,t_n) \in \sigma(E)\}
    \end{align*}

  \begin{itemize}
    \item H is the Herbrand universe, that is, the set of all terms.
    \item We use $ X = Y $ as a notational convenience to denote the
      pair of constraints $ X \subseteq Y $ and $ Y \subseteq X
      $. In the Hindley-Milner type system, constraints occur only in
      this form, and are solved by unification.
    \item Set constraints, in general, are solved by repeated
      application of re-writing rules, as we shall see.
  \end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{This paper}

  \begin{itemize}
  \item Andersen \cite{Andersen94programanalysis} and Steensgard
    \cite{Steensgaard96points-toanalysis} both presented algorithms
    for pointer analysis; this paper formulates both of
    these algorithms as sets of typing rules. 
  \item Typing rules are set constraints and can thus be solved in the
    general framework \cite{F?hndrich97programanalysis} which the
    authors had previously developed.
  \item The resulting implementation (in ML) is compared to a previous,
    more application-specific implementation (in C)
    \cite{Shapiro97fastand}; the former's running time is found to be
    within a small constant factor of the latter.
  \item More concretely, this paper develops typing rules common to
    both algorithms (\boldit{Common}), typing rules specific to each
    algorithm (\boldit{And} and \boldit{Ste}) and shows that the
    type relations/equivalences which arise from
    \boldit{And+Common} and \boldit{Ste+Common} are
    equivalent to the points-to relations in the original algorithms.
  \item Further, the paper shows that the two algorithms are similar
    enough to be represented by a combined set of rules
    (\boldit{Comb}), in which the only difference is in the
    constructor signatures.
  \end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle {The analysis framework}
  \begin{itemize}
    \item Set of sorts S, including Term and Set.
    \item Each n-ary constructor c has a signature $$ c: \iota_1
      \dotso \iota_n : S $$
      where each $\iota_i$ is $s$ (covariant) or $\overline{s}$
      (contravariant) for some $s \in S$.
    \item Sort Term: set of constructors $\Sigma_{Term}$, 
      set of variables $V_{Term}$. Terms: variables from $V_{Term}$ or
      constructed terms following some constructor's signature:
      $$ c:Term \dotso \underbrace{Term \rightarrow Term}_{arity(c)},
      c \in \Sigma_{Term} $$
    \item Sort Set: set of constuctors $\Sigma_{Set}$, operations
      ${\cup, \cap, 0, 1}$. Set expressions follow some constructor's
      signature: 
      $$ c:Set \dotso \underbrace{Set \rightarrow Set}_{arity(c)},
      c \in \Sigma_{Set} $$
      \begin{figure}
        \centering
        \includegraphics[scale=0.3]{set_operations.png}
      \end{figure}
    \item In general, a sort $s$ has a constraint relation
      $\subseteq_s$ and resolution rules for $\subseteq_s$. Term has
      two, $=_t$ (Hindley-Milner style equality) and $=_c$
      (Steensgard-style conditional equality.).
  \end{itemize}

  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{resolution_rules.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{language_syntax.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{andersen_inference_rules.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{common_inference_rules.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{steensgard_inference_rules.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{combination_inference_rules.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{operational_semantics.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{andersen_comparison.png}
  \end{figure}
\end{frame}

\begin{frame}
  \begin{figure}
    \centering
    \includegraphics[scale=0.3]{steensgard_comparison.png}
  \end{figure}
\end{frame}

\section{Test section two}
\begin{frame} Test \end{frame}
\begin{frame} Test \end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{References}
  \bibliographystyle{plain}
  \bibliography{citeseerx,Aiken99,CharatonikP94}
\end{frame}

\end{document}
